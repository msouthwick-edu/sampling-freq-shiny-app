#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    https://shiny.posit.co/
#

# to dos ####
# methods or about tab (simulation conditions, more info on what )
# side panel of perf metrics (helpful flavor text on each page, probs under title of each box)
# ^^ could use a separate box (htmlOutput to dynamically update text; use renderText)
# fit model and pull AR estimates and add to IIV indicator
# MC error tab with MC results lol --> w7 from sim class
# References table
# maybe some type of reveal option by (none, sample size, or by sampling frequency) --> animated graphic
#   could create tabs (static, dynamic-1 sample size, dynamic-2 sf); have tabs on left side
#   or focus on a means of comparison between indicators (check box for each one to display)

# packages ####
# could create a "source script" and call it in with source("file-name.R") and it will run all those packages!
library(shiny) # app
library(shinydashboard) # will be nice for creating tabs (MC error, raw data tables, models fit, etc.)
library(tidyverse) # piping and ggplot
library(ghibli)
library(DT) # data tables

#naming --> slide 39 in week 9
# 

# data ####
load("results-data-arima.RData")
load("outcome-data-arima.RData")
results.plot <- results.plot |> 
  rename("ar" = "dt-ar (phi)")
outcome.long <- outcome.plot |> 
    pivot_longer(
        cols = c(5:11)
    ) |> 
    filter(data == "sampled") |> 
  mutate(indicator = factor(indicator,
                            levels = c("ivar", "isd", "imean", "auto.cor", "dt-ar (phi)"),
                            labels = c("ivar", "isd", "imean", "auto.cor", "ar")))

attributes(outcome.plot$indicator)

ghibli_palettes$MononokeMedium

# custom theme for plots ####
mls_theme <- function(){
  theme_bw() %+replace%
    
    theme(
      
      # text elements
      plot.title = element_text(
        size = rel(1.5),
        face = 'bold',
        hjust = 0.5,
        vjust = 3),
      plot.subtitle = element_text(
        size = rel(1.1)),
      axis.title = element_text(
        size = rel(1.3),
        face = 'bold'),
      axis.text = element_text(
        size = rel(1.3)),
      
      # panel background
      
      panel.background = element_rect(
        fill = "#FFFFFF",
        color = "#534C53FF"),
      
      # legend
      
      legend.position	= "bottom",
      legend.title = element_text(face = "bold",
                                  size = rel(1.1)),
      legend.text = element_text(size = rel(1.1)),
      
      # facet grid
      
      strip.text.x = element_text(
        size = rel(1.3),
        face = "bold",
        color = "white"),
      strip.text.y.right = element_text(
        size = rel(1.3),
        face = "bold",
        color = "white"
        ),
      strip.background.x =
              element_rect(
                fill = "#1F273EFF",
                color = "#1F273EFF"
      ),
      strip.background.y = element_rect(
        fill = "#3D4F7DFF",
        color = "#3D4F7DFF"
      )
      )
}
gg.fill <- scale_fill_manual(values = c("sampled" = "#CD4F38FF", "dgp" = "#B3B8B1FF"),
                             labels = c("Hourly DGP", "Sampled"))

# ui dashboard ####
sidebar <- dashboardSidebar(
    sidebarMenu(
      menuItem(" Method", tabName = "method", icon = icon("list-ol")),
      menuItem(" Results", tabName = "results", icon = icon("dashboard")),
      menuItem(" Metrics Table", icon = icon("table"), tabName = "datatable")
    )
  )

body <- dashboardBody(
  tabItems(
    tabItem("method",
            fluidRow(
              box(title = "Simulation Approach",
                htmlOutput("sim.method"),  
                width=12
                )
              )
            ),
    tabItem("results",
    fluidRow(
             box(
        title = "Selection Box",
        selectInput(inputId = "indicator",
                        label = "Intraindividual Variability Indicator",
                        choices = c("iVAR" = "ivar",
                                    "iSD" = "isd",
                                    "iMean" = "imean",
                                    "Autocorrelation" = "auto.cor",
                                    "AR(1)" = "ar"),
                        selected = "iVar"),
        selectInput(inputId = "name",
                        label = "Performance Metrics",
                        choices = c("Absolute Bias" = "abs.bias",
                                    "Absolute Relative Bias" = "abs.rel.bias",
                                    "Relative Bias" = "rel.bias",
                                    "Mean Squared Error" = "mse",
                                    "Root MSE" = "rmse",
                                    "Efficiency" = "var.eff",
                                    "Mean" = "mean"),
                        selected = "Absolute Relative Bias"),
        # radioButtons(inputId = "animate",
        #                 label = "Animate Plot",
        #                 choices = c("Show All Facets" = "all",
        #                             "Reveal by Sample Size" = "rv.n",
        #                             "Reveal by Sampling Frequency" = "rv.sf"),
        #                 selected = "all"),
        width = 4), # overall width is 12
        box(
          title = "Distribution of Statistics (N=1000)",
          plotOutput("distPlot"),
            width = 8)
    ),

    fluidRow(
      box(
        title = "Performance Metrics",
        uiOutput('abs.bias'),
        htmlOutput("perfDesc"),
        plotOutput("perfPlot"),
          width = 12)
    )
  ),
    tabItem("datatable",
    fluidRow(
      box(
        title = "Data Table",
        dataTableOutput("outcomeTable"),
          width = 12)
      )
    )
  )
)
ui <- dashboardPage(skin = "purple",
  dashboardHeader(title = "Intraindividual Variability",
                  titleWidth = 300),
  sidebar,
  body
)

# server ####
server <- function(input, output) {
    output$distPlot <- renderPlot({
# could save out plots as objects in separate script and load in objects            
        # if(input$indicator == "ivar"){
        #     x1 <- results.sampled$ivar
        #     x2 <- results.dgp$ivar
        #     
        # } else if(input$indicator == "isd"){
        #     x1 <- results.sampled$isd
        #     x2 <- results.dgp$isd
        #     
        # } else if(input$indicator == "imean"){
        #     x1 <- results.sampled$imean
        #     x2 <- results.dgp$imean
        # 
        # } else if(input$indicator == "auto.cor"){
        #     x1 <- results.sampled$auto.cor
        #     x2 <- results.dgp$auto.cor
        #     
        # } else if(input$indicator == "ar"){
        #     x1 <- results.sampled$ar
        #     x2 <- results.dgp$ar
        # }
        
          ggplot(data = results.plot,
                 aes(x=input$indicator, fill=data)) +
            geom_vline(
              data = results.plot |> 
                filter(data == "dgp"),
              xintercept = mean(input$indicator),
                       color = "#CD4F38FF"
                       ) +
            stat_density(
              mapping = aes(), 
              alpha = .7,
              geom = "area",
                position = "identity") + # identity needed to distinguish groups
            scale_y_continuous(breaks = c(0, 10)) +
            scale_fill_manual(c("#3D4F7DFF", "#657060FF")) +
            facet_grid(n.size ~ samp.freq) +
            mls_theme() +
            gg.fill +
            labs(title = paste0("Distribution of ", input$indicator, " Estimates")) +
            xlab("Estimate") + 
            ylab("Density")
       
            })
    
    output$perfPlot <- renderPlot({ # could include description of the performance metric and implications underneath it or in the side panel!
      
       ggplot(data = outcome.long |> 
               filter(indicator == input$indicator & name == input$name), # considering creating select option
               aes(x=n.size, y=value, group = 1)) +
        geom_line(color = "#CD4F38FF",
                  linewidth = 2) +
        geom_point(fill = "#67271BFF",
                   size = 3) +
        facet_grid(~samp.freq,
                   scales = "free") +
        mls_theme() +
        labs(
          title = paste0(input$name),
          y = "Value",
          x = "Sample Size")
      # 
      # ggplot(data = outcome.long |> 
      #          filter(indicator == input$indicator & name == input$name), # considering creating select option
      #          aes(x=n.size, y=value)) +
      #   geom_bar(stat="identity", position="dodge") +
      #   facet_grid(~samp.freq,
      #              scales="free") + 
      #       mls_theme() +
      #       gg.outcome.theme +
      #         xlab("Sample Size") + 
      #         gg.outcome.fill +
      #         guides(fill = FALSE)
    })
    output$abs.bias <- renderUI({
      withMathJax(
        helpText("Absolute Bias Formula: $\sum_{i=1}^n |\hat_theta - $")
      )
    })
    output$perfDesc <- renderText({
      
    if(input$name == "abs.bias"){
      HTML("Calculated by: mean(abs(x - x-bar))")
    } else if(input$name == "abs.rel.bias"){
      HTML("<strong>this is absolute relative bias!</strong>")
    }
    }) # work on!
    output$outcomeTable <- DT::renderDataTable({
  
      DT::datatable(outcome.plot |> 
                          mutate(abs.bias = round(abs.bias, digits = 3),
                                 abs.rel.bias = round(abs.rel.bias, digits = 3),
                                 rel.bias = round(rel.bias, digits = 3),
                                 mse = round(mse, digits = 3),
                                 rmse = round(rmse, digits = 3),
                                 var.eff = round(var.eff, digits = 3),
                                 mean = round(mean, digits = 3))
      , class = 'cell-border stripe', filter = 'top', rownames = FALSE)
        })
    
    output$sim.method <- renderText({
      HTML("<strong>Raw HTML!</strong>")
    })
}

# Run the application ####
shinyApp(ui = ui, server = server)


